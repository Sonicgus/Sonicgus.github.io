<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>A Jornada da Esfera</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; touch-action: none; }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #title-card {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 1s;
            z-index: 100;
            text-align: center;
        }
        h1 { margin: 0; font-size: 3rem; color: #ffd700; }
        h2 { margin-top: 10px; font-weight: 300; color: #aaa; }
        p { max-width: 600px; line-height: 1.6; margin: 20px; font-size: 1.1rem; }
        button {
            padding: 15px 40px;
            font-size: 1.2rem;
            background: white;
            border: none;
            cursor: pointer;
            border-radius: 30px;
            transition: transform 0.2s, background 0.2s;
            color: #333;
            font-weight: bold;
            margin: 10px;
        }
        button:hover { transform: scale(1.1); background: #f0f0f0; }
        #level-info { font-size: 1.5rem; font-weight: bold; transition: color 0.5s; }
        #instruction { font-size: 1.1rem; color: #ddd; margin-top: 5px; }
        #task-counter { font-size: 1.2rem; color: #88ccff; display: none; }
        
        /* Fade Overlay */
        #fade-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 200;
            transition: opacity 3s ease-in-out;
        }
        
        /* Flash Effect Overlay */
        #flash-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 150;
            transition: opacity 0.5s;
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            text-align: center;
            width: 100%;
        }

        #gyro-btn {
            background: #4488ff;
            color: white;
            display: none;
        }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div>
            <div id="level-info">Prólogo</div>
            <div id="instruction">Prepara-te para a jornada.</div>
            <div id="task-counter">Dias: 0</div>
        </div>
        <div id="controls-hint">Setas, WASD ou Inclinar Telemóvel</div>
    </div>

    <div id="title-card">
        <h1>A Jornada da Esfera</h1>
        <h2 id="phase-title">Prólogo</h2>
        <p id="phase-desc">Uma representação jogável do sentido da vida.<br>Agora num mundo contínuo e conectado.</p>
        <!-- Botões com efeitos sonoros -->
        <button id="start-btn" onmouseenter="playHoverSound()">Começar Jornada</button>
        <button id="gyro-btn" onmouseenter="playHoverSound()">Ativar Sensores de Movimento</button>
    </div>

    <div id="fade-overlay"></div>
    <div id="flash-overlay"></div>

    <script>
        // --- WAKE LOCK (PREVENIR ECRÃ DE DORMIR) ---
        let wakeLock = null;
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock active');
                }
            } catch (err) {
                console.log('Wake Lock error:', err);
            }
        }
        
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // --- SISTEMA DE ÁUDIO ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let musicInterval;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
                startAmbientMusic();
            } else if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playTone(freq, type, duration, vol = 0.1) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playHoverSound() {
            if(!audioCtx) return;
            playTone(400, 'sine', 0.1, 0.05);
        }

        function playClickSound() {
            initAudio();
            playTone(600, 'square', 0.2, 0.1);
            playTone(800, 'sine', 0.3, 0.1);
        }

        function playWinSound() {
            playTone(440, 'sine', 0.5, 0.1);
            setTimeout(() => playTone(554, 'sine', 0.5, 0.1), 100);
            setTimeout(() => playTone(659, 'sine', 1.0, 0.1), 200);
        }

        function playMudSound() {
            playTone(100 + Math.random()*50, 'sawtooth', 0.1, 0.05);
        }

        function playClinkSound() {
            playTone(1200, 'sine', 0.1, 0.05);
        }

        function startAmbientMusic() {
            const notes = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; 
            let noteIdx = 0;
            if (musicInterval) clearInterval(musicInterval);
            musicInterval = setInterval(() => {
                const freq = notes[Math.floor(Math.random() * notes.length)];
                playTone(freq / 2, 'sine', 4, 0.02);
                if(Math.random() > 0.7) {
                    setTimeout(() => playTone(freq * 2, 'triangle', 2, 0.01), 500);
                }
            }, 3000);
        }


        // --- CONFIGURAÇÃO GERAL ---
        const ISLAND_SPACING = 60; 

        // --- CONFIGURAÇÃO DO MOTOR (THREE.JS) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 80); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Luzes
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- ESTADO DO JOGO ---
        const gameState = {
            currentLevelIndex: 0,
            started: false,
            completed: false,
            score: 0, 
            bridgeBuilt: [false, false, false, false, false],
            levelsInitialized: false,
            lastMudSoundTime: 0
        };

        // --- CONTROLO GYRO ---
        const gyro = { active: false, beta: 0, gamma: 0 };

        // --- JOGADOR ---
        const player = {
            mesh: null,
            velocity: new THREE.Vector3(),
            speed: 0.1,
            friction: 0.8,
            radius: 0.5,
            isDirty: false,
            holdingBox: false
        };

        // Arrays globais
        let allInteractables = []; 
        let allLevelObjects = [];
        let particleSystems = [];

        // Input
        const keys = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', (e) => {
            if(e.key === 'ArrowUp' || e.key === 'w') keys.w = true;
            if(e.key === 'ArrowDown' || e.key === 's') keys.s = true;
            if(e.key === 'ArrowLeft' || e.key === 'a') keys.a = true;
            if(e.key === 'ArrowRight' || e.key === 'd') keys.d = true;
        });
        window.addEventListener('keyup', (e) => {
            if(e.key === 'ArrowUp' || e.key === 'w') keys.w = false;
            if(e.key === 'ArrowDown' || e.key === 's') keys.s = false;
            if(e.key === 'ArrowLeft' || e.key === 'a') keys.a = false;
            if(e.key === 'ArrowRight' || e.key === 'd') keys.d = false;
        });

        // Gyro Setup
        const gyroBtn = document.getElementById('gyro-btn');
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
            gyroBtn.style.display = 'inline-block';
            gyroBtn.addEventListener('click', () => {
                playClickSound();
                DeviceOrientationEvent.requestPermission().then(res => {
                    if (res === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        gyroBtn.style.display = 'none';
                        gyro.active = true;
                    }
                });
            });
        } else if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', handleOrientation);
            gyro.active = true;
        }
        function handleOrientation(e) { gyro.beta = e.beta; gyro.gamma = e.gamma; }


        // --- DEFINIÇÃO DE NÍVEIS ---
        const levels = [
            {
                id: 1,
                name: "Ilha 1: O Bebé",
                desc: "Empurra as formas para os encaixes.",
                color: 0xffcccc,
                zOffset: 0,
                setup: setupLevel1,
                update: updateLevel1
            },
            {
                id: 2,
                name: "Ilha 2: A Criança",
                desc: "Suja-te na lama para criar a ponte.",
                color: 0x44aa44,
                zOffset: -ISLAND_SPACING,
                setup: setupLevel2,
                update: updateLevel2
            },
            {
                id: 3,
                name: "Ilha 3: O Jovem",
                desc: "Recolhe letras para construir o teu caminho.",
                color: 0x3366cc,
                zOffset: -ISLAND_SPACING * 2,
                setup: setupLevel3,
                update: updateLevel3
            },
            {
                id: 4,
                name: "Ilha 4: O Adulto",
                desc: "Trabalha para construir o futuro.",
                color: 0x888888,
                zOffset: -ISLAND_SPACING * 3,
                setup: setupLevel4,
                update: updateLevel4
            },
            {
                id: 5,
                name: "Ilha 5: O Idoso",
                desc: "Caminha para a luz.",
                color: 0xdddddd,
                zOffset: -ISLAND_SPACING * 4,
                setup: setupLevel5,
                update: updateLevel5
            }
        ];

        // UI References
        const titleCard = document.getElementById('title-card');
        const startBtn = document.getElementById('start-btn');
        const levelInfoUI = document.getElementById('level-info');
        const instructionUI = document.getElementById('instruction');
        const flashOverlay = document.getElementById('flash-overlay');

        startBtn.addEventListener('click', () => {
            playClickSound();
            if (!gameState.started) {
                initGame();
            }
            titleCard.style.opacity = 0;
            setTimeout(() => titleCard.style.display = 'none', 1000);
        });

        function initGame() {
            gameState.started = true;
            initAudio();
            requestWakeLock();
            
            const waterGeo = new THREE.PlaneGeometry(200, 600);
            const waterMat = new THREE.MeshBasicMaterial({ color: 0x004488 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -2;
            water.position.z = -150; 
            scene.add(water);

            levels.forEach((lvl, index) => {
                const planeGeo = new THREE.CylinderGeometry(15, 15, 1, 32);
                const planeMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
                const ground = new THREE.Mesh(planeGeo, planeMat);
                ground.position.set(0, -0.5, lvl.zOffset);
                ground.receiveShadow = true;
                ground.userData = { type: 'ground', levelIndex: index };
                scene.add(ground);
                allLevelObjects.push(ground);

                lvl.setup(lvl.zOffset);
            });

            createPlayer(0.4, 0xffcccc, 0, 0);
            updateUIForLevel(0);
        }

        function createPlayer(radius, color, x, z) {
            if(player.mesh) scene.remove(player.mesh);
            
            const geo = new THREE.SphereGeometry(radius, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, radius, z);
            mesh.castShadow = true;
            scene.add(mesh);
            
            player.mesh = mesh;
            player.radius = radius;
            player.velocity.set(0,0,0);
        }

        function triggerLevelArrivalEffect(levelIndex) {
            playWinSound(); 

            flashOverlay.style.opacity = 0.8;
            setTimeout(() => flashOverlay.style.opacity = 0, 500);

            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const zCenter = levels[levelIndex].zOffset;

            for (let i = 0; i < particleCount; i++) {
                positions.push(0, 2, zCenter + 12); 
                velocities.push(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: levels[levelIndex].color, size: 0.5 });
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            particleSystems.push({ mesh: particles, velocities: velocities, age: 0 });
        }

        function updateParticles() {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const sys = particleSystems[i];
                const positions = sys.mesh.geometry.attributes.position.array;
                sys.age++;
                for (let j = 0; j < sys.velocities.length / 3; j++) {
                    positions[j*3] += sys.velocities[j*3];
                    positions[j*3+1] += sys.velocities[j*3+1];
                    positions[j*3+2] += sys.velocities[j*3+2];
                }
                sys.mesh.geometry.attributes.position.needsUpdate = true;
                if (sys.age > 60) {
                    scene.remove(sys.mesh);
                    particleSystems.splice(i, 1);
                }
            }
        }

        // --- LOGICA ESPECÍFICA DOS NÍVEIS ---

        // ILHA 1
        function setupLevel1(zOffset) {
            const shapesData = [
                { type: 'box', color: 0xff0000, x: -3, z: 3 + zOffset },
                { type: 'sphere', color: 0x00ff00, x: 0, z: 3 + zOffset },
                { type: 'cone', color: 0x0000ff, x: 3, z: 3 + zOffset }
            ];
            const slotsData = [
                { type: 'box', x: -3, z: -5 + zOffset },
                { type: 'sphere', x: 0, z: -5 + zOffset },
                { type: 'cone', x: 3, z: -5 + zOffset }
            ];

            shapesData.forEach(d => {
                let geo;
                if(d.type === 'box') geo = new THREE.BoxGeometry(1,1,1);
                if(d.type === 'sphere') geo = new THREE.SphereGeometry(0.6);
                if(d.type === 'cone') geo = new THREE.ConeGeometry(0.6, 1.2);
                const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: d.color}));
                mesh.position.set(d.x, 0.5, d.z);
                mesh.castShadow = true;
                mesh.userData = { type: 'lvl1_shape', shapeType: d.type, locked: false, originalGeo: geo };
                scene.add(mesh);
                allInteractables.push(mesh);
            });

            slotsData.forEach(d => {
                let geo;
                if(d.type === 'box') geo = new THREE.BoxGeometry(1.2,1.2,1.2);
                if(d.type === 'sphere') geo = new THREE.SphereGeometry(0.7);
                if(d.type === 'cone') geo = new THREE.ConeGeometry(0.7, 1.3);
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true, opacity: 0.5, transparent: true}));
                mesh.position.set(d.x, 0.5, d.z);
                mesh.userData = { type: 'lvl1_slot', shapeType: d.type };
                scene.add(mesh);
                allLevelObjects.push(mesh);
            });
        }

        function updateLevel1() {
            if (gameState.bridgeBuilt[0]) return;

            let solvedCount = 0;
            const zOffset = levels[0].zOffset;

            allInteractables.forEach(obj => {
                if (obj.userData.type !== 'lvl1_shape') return;
                
                if (obj.userData.locked) {
                    solvedCount++;
                    return;
                }

                const dist = player.mesh.position.distanceTo(obj.position);
                if (dist < player.radius + 0.8) {
                    const pushDir = new THREE.Vector3().subVectors(obj.position, player.mesh.position);
                    pushDir.y = 0; pushDir.normalize();
                    obj.position.add(pushDir.multiplyScalar(0.1));
                    obj.position.y = 0.5;
                }

                allLevelObjects.forEach(slot => {
                    if (slot.userData.type === 'lvl1_slot' && slot.userData.shapeType === obj.userData.shapeType) {
                        const dx = obj.position.x - slot.position.x;
                        const dz = obj.position.z - slot.position.z;
                        if (Math.sqrt(dx*dx + dz*dz) < 1) {
                            obj.position.copy(slot.position);
                            obj.userData.locked = true;
                            slot.visible = false; 
                            obj.material.emissive = new THREE.Color(0x333333);
                            playClinkSound();
                        }
                    }
                });
            });

            if (solvedCount === 3) {
                gameState.bridgeBuilt[0] = true;
                instructionUI.innerText = "As formas constroem o caminho!";
                
                const shapes = allInteractables.filter(o => o.userData.type === 'lvl1_shape');
                const bridgeZStart = zOffset - 15;
                const bridgeZEnd = levels[1].zOffset + 15;

                shapes.forEach((s, i) => {
                    const targetZ = bridgeZStart - (i+1)*10;
                    s.position.set(0, 0, targetZ);
                    s.scale.set(3, 0.2, 3); 
                    s.userData.isBridge = true;
                });
                
                const filler = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 40), new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.3}));
                filler.position.set(0, -0.1, (bridgeZStart + bridgeZEnd)/2);
                scene.add(filler);
            }
        }


        // ILHA 2
        function setupLevel2(zOffset) {
            for(let i=0; i<5; i++) {
                const puddle = new THREE.Mesh(new THREE.CircleGeometry(2, 32), new THREE.MeshBasicMaterial({ color: 0x3e2723 }));
                puddle.rotation.x = -Math.PI/2;
                puddle.position.set((Math.random()*14)-7, 0.01, zOffset + (Math.random()*14)-7);
                puddle.userData = { type: 'lvl2_mud' };
                scene.add(puddle);
                allLevelObjects.push(puddle);
            }
        }

        function updateLevel2() {
            const zOffset = levels[1].zOffset;
            let inMud = false;
            allLevelObjects.forEach(obj => {
                if(obj.userData.type === 'lvl2_mud') {
                    const dx = player.mesh.position.x - obj.position.x;
                    const dz = player.mesh.position.z - obj.position.z;
                    if(Math.sqrt(dx*dx + dz*dz) < 2) inMud = true;
                }
            });

            if(inMud && gameState.currentLevelIndex === 1) {
                player.isDirty = true;
                player.mesh.material.color.setHex(0x3e2723);
                if (Date.now() - gameState.lastMudSoundTime > 400 && player.velocity.length() > 0.01) {
                    playMudSound();
                    gameState.lastMudSoundTime = Date.now();
                }
            }

            const bridgeStartZ = zOffset - 14;
            
            if(player.isDirty && player.mesh.position.z < bridgeStartZ + 2 && player.mesh.position.z > bridgeStartZ - 30) {
                 if(player.velocity.length() > 0.01 && Math.random() > 0.4) {
                    const drip = new THREE.Mesh(
                        new THREE.CircleGeometry(0.5, 8),
                        new THREE.MeshBasicMaterial({ color: 0x3e2723 })
                    );
                    drip.rotation.x = -Math.PI/2;
                    drip.position.copy(player.mesh.position);
                    drip.position.y = 0.02;
                    scene.add(drip);
                    
                    if(!gameState.bridgeBuilt[1]) {
                        gameState.score++;
                        if(gameState.score > 40) {
                            gameState.bridgeBuilt[1] = true;
                            instructionUI.innerText = "O teu rasto é o caminho. Segue em frente.";
                        }
                    }
                 }
            }
        }


        // ILHA 3
        function setupLevel3(zOffset) {
            const clockFace = new THREE.Mesh(new THREE.CircleGeometry(9, 32), new THREE.MeshBasicMaterial({ color: 0x224488, opacity: 0.3, transparent: true }));
            clockFace.rotation.x = -Math.PI/2;
            clockFace.position.set(0, 0.01, zOffset);
            scene.add(clockFace);
            allLevelObjects.push(clockFace);

            const letters = ['V', 'I', 'D', 'A'];
            const positions = [{x: -2, z: 0}, {x: -0.7, z: 0}, {x: 0.7, z: 0}, {x: 2, z: 0}];
            letters.forEach((char, i) => {
                const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
                const ctx = canvas.getContext('2d'); ctx.fillStyle='#ffff00'; ctx.font='bold 50px Arial'; ctx.fillText(char, 15, 50);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(canvas)}));
                sprite.position.set(positions[i].x, 1.5, positions[i].z + zOffset);
                sprite.scale.set(2,2,1);
                sprite.userData = { type: 'lvl3_letter', char: char };
                scene.add(sprite);
                allInteractables.push(sprite);
            });
            
            for (let i = 1; i <= 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x = Math.sin(angle) * 7.5;
                const z = -Math.cos(angle) * 7.5;
                const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
                const ctx = canvas.getContext('2d'); ctx.fillStyle='#fff'; ctx.font='bold 40px Arial'; ctx.fillText(i, 20, 40);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(canvas)}));
                sprite.position.set(x, 1.5, z + zOffset);
                scene.add(sprite);
                allInteractables.push(sprite); 
            }
        }

        // Função auxiliar para criar bloco com letra
        function createBridgeBlock(char, index, zOffset) {
             const boxGeo = new THREE.BoxGeometry(4, 0.5, 6);
             
             // Criar textura com a letra
             const canvas = document.createElement('canvas');
             canvas.width = 256; canvas.height = 256;
             const ctx = canvas.getContext('2d');
             
             // Fundo azul
             ctx.fillStyle = '#3366cc';
             ctx.fillRect(0, 0, 256, 256);
             
             // Letra
             ctx.fillStyle = '#ffffff';
             ctx.font = 'bold 150px Arial';
             ctx.textAlign = 'center';
             ctx.textBaseline = 'middle';
             ctx.fillText(char, 128, 128);
             
             // Borda
             ctx.strokeStyle = '#ffffff';
             ctx.lineWidth = 10;
             ctx.strokeRect(10, 10, 236, 236);
             
             const texture = new THREE.CanvasTexture(canvas);
             const mat = new THREE.MeshStandardMaterial({ map: texture });
             
             const box = new THREE.Mesh(boxGeo, mat);
             // Posicionar bloco sequencialmente (0, 1, 2, 3)
             box.position.set(0, 0, zOffset - 18 - (index * 6.5));
             scene.add(box);
             
             // Pequena animação de "pop"
             box.scale.set(0.1, 0.1, 0.1);
             let s = 0.1;
             const grow = setInterval(() => {
                 s += 0.1;
                 box.scale.set(s, s, s);
                 if (s >= 1) clearInterval(grow);
             }, 20);
        }

        function updateLevel3() {
            if (gameState.bridgeBuilt[2]) return;
            let lettersFound = 0;
            const zOffset = levels[2].zOffset;

            allInteractables.forEach(obj => {
                if (obj.userData.type === 'lvl3_letter') {
                    if(obj.visible && player.mesh.position.distanceTo(obj.position) < 1.5) {
                        obj.visible = false;
                        gameState.score++; // Incrementa score (1, 2, 3, 4...)
                        playClinkSound();
                        
                        // Adiciona bloco IMEDIATAMENTE
                        // Usa gameState.score-1 para ter índice 0,1,2,3
                        createBridgeBlock(obj.userData.char, gameState.score - 1, zOffset);
                        
                        instructionUI.innerText = `Adicionado bloco "${obj.userData.char}" à ponte!`;
                    }
                    if(!obj.visible) lettersFound++;
                }
            });

            if(lettersFound === 4) {
                gameState.bridgeBuilt[2] = true;
                instructionUI.innerText = "Caminho completo. O conhecimento é o teu suporte.";
            }
        }


        // ILHA 4
        function setupLevel4(zOffset) {
            const pickupZone = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 3), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            pickupZone.position.set(-6, 0.01, zOffset);
            pickupZone.userData = { type: 'lvl4_zone' };
            scene.add(pickupZone);
            
            const dropZone = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 3), new THREE.MeshBasicMaterial({color: 0xff0000}));
            dropZone.position.set(6, 0.01, zOffset);
            dropZone.userData = { type: 'lvl4_zone' };
            scene.add(dropZone);

            spawnBoxLevel4(zOffset);
            gameState.workDays = 0; 
        }

        function spawnBoxLevel4(zOffset) {
            const box = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            box.position.set(-6, 1, zOffset);
            box.userData = { type: 'lvl4_cargo' };
            scene.add(box);
            allInteractables.push(box);
        }

        function updateLevel4() {
            if (gameState.bridgeBuilt[3]) return;
            const zOffset = levels[3].zOffset;
            
            if (player.holdingBox) {
                if (player.mesh.position.distanceTo(new THREE.Vector3(6, 0, zOffset)) < 2) {
                    player.holdingBox = false;
                    player.mesh.children = player.mesh.children.filter(c => c.userData.id !== 'heldBox');
                    
                    gameState.workDays = (gameState.workDays || 0) + 1;
                    document.getElementById('task-counter').innerText = `Dias: ${gameState.workDays}`;
                    playClinkSound(); 
                    
                    const piece = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 6), new THREE.MeshStandardMaterial({color: 0x888888}));
                    piece.position.set(0, 0, zOffset - 15 - (gameState.workDays * 6));
                    scene.add(piece);

                    if (gameState.workDays < 5) {
                        spawnBoxLevel4(zOffset);
                    } else {
                        gameState.bridgeBuilt[3] = true;
                        instructionUI.innerText = "Reforma alcançada. Segue em frente.";
                    }
                }
            } else {
                allInteractables.forEach(obj => {
                    if (obj.userData.type === 'lvl4_cargo' && obj.visible && player.mesh.position.distanceTo(obj.position) < 1.5) {
                        obj.visible = false;
                        player.holdingBox = true;
                        playClinkSound(); 
                        const carryBox = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({color:0x8B4513}));
                        carryBox.position.y = 1.2;
                        carryBox.userData = { id: 'heldBox' };
                        player.mesh.add(carryBox);
                    }
                });
            }
        }


        // ILHA 5
        function setupLevel5(zOffset) {
            createGhost(new THREE.ConeGeometry(0.6,1.2), -3, zOffset + 5, 0xffcccc);
            createGhost(new THREE.CircleGeometry(2, 32), 3, zOffset, 0x5c4033);
            
            const lightEnd = new THREE.PointLight(0xffffff, 2, 30);
            lightEnd.position.set(0, 5, zOffset - 20);
            scene.add(lightEnd);
            
            const orb = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({color:0xffffff}));
            orb.position.set(0, 2, zOffset - 20);
            orb.userData = { type: 'end_light' };
            allInteractables.push(orb);
            scene.add(orb);
        }
        
        function createGhost(geo, x, z, color) {
            const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:color, transparent:true, opacity:0.5, wireframe:true}));
            mesh.position.set(x, 0.5, z);
            if(geo.type==='CircleGeometry') mesh.rotation.x = -Math.PI/2;
            scene.add(mesh);
        }

        function updateLevel5() {
            const zOffset = levels[4].zOffset;
            allInteractables.forEach(obj => {
                if(obj.userData.type === 'end_light' && player.mesh.position.distanceTo(obj.position) < 3) {
                    document.getElementById('fade-overlay').style.opacity = 1;
                    if (audioCtx) {
                         playTone(523, 'sine', 2, 0.1); 
                         playTone(659, 'sine', 2, 0.1);
                         playTone(784, 'sine', 2, 0.1);
                    }
                    setTimeout(()=> { alert("Fim da Jornada."); location.reload(); }, 4000);
                }
            });
        }


        // --- SISTEMA DE ZONAS ---
        function updateZoneLogic() {
            const pZ = player.mesh.position.z;
            let newLevelIndex = gameState.currentLevelIndex;

            levels.forEach((lvl, i) => {
                if (Math.abs(pZ - lvl.zOffset) < 20) {
                    newLevelIndex = i;
                }
            });

            if (newLevelIndex !== gameState.currentLevelIndex) {
                gameState.currentLevelIndex = newLevelIndex;
                updateUIForLevel(newLevelIndex);
                triggerLevelArrivalEffect(newLevelIndex);
                
                player.mesh.material.color.setHex(levels[newLevelIndex].color);
                gameState.score = 0; 
                
                if(newLevelIndex === 3) {
                    const scar = new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.05, 16, 100), new THREE.MeshBasicMaterial({ color: 0x220000 }));
                    scar.rotation.x = Math.PI/4;
                    player.mesh.add(scar);
                }
                if(newLevelIndex === 4) {
                    player.friction = 0.99;
                    scene.fog.density = 0.05;
                }
            }
        }

        function updateUIForLevel(index) {
            const lvl = levels[index];
            levelInfoUI.innerText = lvl.name;
            levelInfoUI.style.color = '#' + lvl.color.toString(16);
            instructionUI.innerText = lvl.desc;
            document.getElementById('task-counter').style.display = (index === 3) ? 'block' : 'none';
        }


        // --- LOOP PRINCIPAL ---
        function animate() {
            requestAnimationFrame(animate);
            if (!gameState.started || !player.mesh) return;

            // INPUT
            if (keys.w) player.velocity.z -= player.speed * 0.1;
            if (keys.s) player.velocity.z += player.speed * 0.1;
            if (keys.a) player.velocity.x -= player.speed * 0.1;
            if (keys.d) player.velocity.x += player.speed * 0.1;
            
            if (gyro.active) {
                 const deadzone = 2;
                 if (Math.abs(gyro.beta) > deadzone) player.velocity.z += THREE.MathUtils.clamp(gyro.beta, -45, 45) * 0.003 * player.speed;
                 if (Math.abs(gyro.gamma) > deadzone) player.velocity.x += THREE.MathUtils.clamp(gyro.gamma, -45, 45) * 0.003 * player.speed;
            }

            player.mesh.position.add(player.velocity);
            player.velocity.multiplyScalar(player.friction);

            // COLISÃO BÁSICA COM CHÃO
            if (Math.abs(player.mesh.position.x) > 15) {
                player.mesh.position.x = 0; 
                player.velocity.set(0,0,0);
            }

            camera.position.x = player.mesh.position.x;
            camera.position.z = player.mesh.position.z + 12;
            camera.position.y = player.mesh.position.y + 10;
            camera.lookAt(player.mesh.position);

            updateLevel1();
            updateLevel2();
            updateLevel3();
            updateLevel4();
            updateLevel5();
            
            updateZoneLogic();
            updateParticles();

            renderer.render(scene, camera);
        }

        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
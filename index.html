<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desenhador de Funções Algébricas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; 
        }
        canvas {
            cursor: crosshair;
        }
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="p-4 bg-slate-800 shadow-md flex justify-between items-center z-10">
        <div>
            <h1 class="text-xl font-bold text-blue-400">Descobridor de Funções</h1>
            <p class="text-xs text-slate-400">Suporta: Polinómios, Sen/Cos, Exponenciais ($e^x$) e Logaritmos ($\ln x$)</p>
        </div>
        <div class="flex gap-2">
            <!-- Botão Toggle Resultados -->
            <button onclick="toggleResults()" class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-2 rounded-lg font-medium transition shadow-lg flex items-center gap-2" title="Mostrar/Ocultar Equações">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                <span class="hidden sm:inline">Equações</span>
            </button>
            
            <button onclick="analyzeAllCurves()" class="bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-2 rounded-lg font-medium transition shadow-lg flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                Calcular
            </button>
            <button onclick="clearAll()" class="bg-slate-600 hover:bg-slate-500 text-white px-4 py-2 rounded-lg font-medium transition shadow-lg">
                Limpar
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow relative flex items-center justify-center bg-slate-900">
        
        <!-- Result Overlay -->
        <div id="resultPanel" class="absolute top-4 left-4 right-4 md:left-auto md:right-4 md:w-96 max-h-[80vh] overflow-y-auto bg-slate-800/95 backdrop-blur-sm p-4 rounded-xl border border-slate-700 shadow-2xl hidden transition-all z-20 flex flex-col gap-3">
            <div class="flex justify-between items-center border-b border-slate-700 pb-2">
                <h3 class="text-sm uppercase tracking-wider text-slate-400 font-bold">Funções Detetadas</h3>
                <span id="functionCount" class="text-xs text-blue-400 bg-blue-400/10 px-2 py-1 rounded-full">0</span>
                <!-- Pequeno botão X para fechar também no painel -->
                <button onclick="toggleResults()" class="text-slate-400 hover:text-white ml-auto">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            
            <div id="equationsList" class="flex flex-col gap-2">
                <!-- Template Item -->
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="relative shadow-2xl rounded-lg overflow-hidden border border-slate-700" style="width: 95%; height: 85%;">
            <canvas id="mainCanvas" class="bg-slate-950 w-full h-full"></canvas>
            
            <div id="instructions" class="pointer-events-none absolute inset-0 flex flex-col items-center justify-center text-slate-500 select-none">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-4 opacity-50" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                </svg>
                <p class="text-lg">Arraste para desenhar</p>
                <p class="text-sm opacity-70">Ligue pontos para criar funções por partes (piecewise)</p>
            </div>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const instructions = document.getElementById('instructions');
        const resultPanel = document.getElementById('resultPanel');
        const equationsList = document.getElementById('equationsList');
        const functionCount = document.getElementById('functionCount');
        
        // State
        let isDrawing = false;
        let strokes = []; 
        let currentStroke = []; 
        let analyzedModels = []; 
        
        let width, height;
        let originX, originY;
        let scale = 40; 

        function resize() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            width = canvas.width;
            height = canvas.height;
            originX = width / 2;
            originY = height / 2;
            renderAll();
        }
        window.addEventListener('resize', resize);

        function toggleResults() {
            if (resultPanel.classList.contains('hidden')) {
                resultPanel.classList.remove('hidden');
            } else {
                resultPanel.classList.add('hidden');
            }
        }

        function startDrawing(e) {
            isDrawing = true;
            instructions.style.opacity = '0';
            // resultPanel.classList.add('hidden'); // Removed auto-hide on draw to keep context if desired
            analyzedModels = []; 
            
            let {x, y} = getPos(e);
            
            // --- LOGIC: SNAP TO PREVIOUS STROKE BUT CREATE NEW ONE ---
            if (strokes.length > 0) {
                const lastStroke = strokes[strokes.length - 1];
                if (lastStroke.length > 0) {
                    const lastPt = lastStroke[lastStroke.length - 1];
                    const dist = Math.sqrt(Math.pow(x - lastPt.x, 2) + Math.pow(y - lastPt.y, 2));
                    
                    if (dist < 20) {
                        x = lastPt.x;
                        y = lastPt.y;
                    }
                }
            }

            currentStroke = [];
            strokes.push(currentStroke);
            currentStroke.push({x, y});
            
            renderAll(); 
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.strokeStyle = '#60a5fa'; 
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        function draw(e) {
            if (!isDrawing) return;
            const {x, y} = getPos(e);
            
            const last = currentStroke[currentStroke.length-1];
            if (!last) {
                currentStroke.push({x, y});
                return;
            }

            const dist = Math.sqrt(Math.pow(x - last.x, 2) + Math.pow(y - last.y, 2));
            if (dist > 5) {
                currentStroke.push({x, y});
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        }

        function stopDrawing() { 
            isDrawing = false; 
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX || (e.touches && e.touches[0].clientX);
            let clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        // Listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, {passive: false});
        canvas.addEventListener('touchend', stopDrawing);

        // --- RENDER SYSTEM ---

        function renderAll() {
            drawGrid();
            drawRawStrokes();
            if (analyzedModels.length > 0) {
                drawAnalyzedCurves();
            }
        }

        function drawGrid() {
            ctx.clearRect(0, 0, width, height);
            
            ctx.strokeStyle = '#1e293b'; 
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x = originX; x < width; x+=scale) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            for(let x = originX; x > 0; x-=scale) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            for(let y = originY; y < height; y+=scale) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            for(let y = originY; y > 0; y-=scale) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();

            ctx.strokeStyle = '#f8fafc'; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, originY); ctx.lineTo(width, originY); 
            ctx.moveTo(originX, 0); ctx.lineTo(originX, height); 
            ctx.stroke();

            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 12px monospace';
            ctx.fillText("y", originX + 10, 20);
            ctx.fillText("x", width - 20, originY - 10);
            ctx.fillText("(0,0)", originX + 5, originY + 15);
        }

        function drawRawStrokes() {
            ctx.strokeStyle = '#60a5fa'; 
            ctx.lineWidth = 3;
            ctx.setLineDash([]); // Ensure solid line for user drawing
            
            strokes.forEach(stroke => {
                if(stroke.length < 1) return;
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for(let i=1; i<stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
                ctx.stroke();
            });
        }

        function clearAll() {
            strokes = [];
            currentStroke = [];
            analyzedModels = [];
            instructions.style.opacity = '1';
            resultPanel.classList.add('hidden');
            renderAll();
        }

        // --- MATH & ANALYSIS ---

        function canvasToMath(pt) {
            return { x: (pt.x - originX) / scale, y: -(pt.y - originY) / scale };
        }

        function mathToCanvas(x, y) {
            return { x: (x * scale) + originX, y: (-y * scale) + originY };
        }

        function analyzeAllCurves() {
            analyzedModels = [];
            equationsList.innerHTML = "";
            let count = 0;

            strokes.forEach((stroke, index) => {
                if (stroke.length < 5) return; 

                const mathPoints = stroke.map(canvasToMath);
                
                const xs = mathPoints.map(p => p.x);
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);

                const model = findBestModel(mathPoints, minX, maxX);
                
                if (model) {
                    model.id = index + 1;
                    model.domain = { min: minX, max: maxX };
                    analyzedModels.push(model);
                    addResultToUI(model);
                    count++;
                }
            });

            if (count > 0) {
                functionCount.innerText = count;
                resultPanel.classList.remove('hidden');
                renderAll(); 
                if (window.MathJax) MathJax.typesetPromise([equationsList]);
            } else {
                alert("Não detetei curvas claras. Tente desenhar um pouco mais.");
            }
        }

        function findBestModel(points, minX, maxX) {
            // --- PASSO 1: CALCULAR GEOMETRIA ---
            let directionChanges = 0;
            let lastSign = 0;
            const stride = Math.max(1, Math.floor(points.length / 10));
            for(let i=stride; i<points.length; i+=stride) {
                let diff = points[i].y - points[i-stride].y;
                if (Math.abs(diff) < 0.05) continue;
                let sign = Math.sign(diff);
                if (lastSign !== 0 && sign !== lastSign) {
                    directionChanges++;
                }
                lastSign = sign;
            }

            const rawQuad = fitPolynomial(points, 2);
            const isConvex = (!isNaN(rawQuad.r2) && rawQuad.coeffs[2] > 0);
            const isConcave = (!isNaN(rawQuad.r2) && rawQuad.coeffs[2] < 0);

            const ys = points.map(p => p.y);
            const height = Math.max(...ys) - Math.min(...ys);
            const startY = points[0].y;
            const endY = points[points.length - 1].y;
            const yDiff = Math.abs(startY - endY);

            let isLoopShape = (height > 0.1 && (yDiff / height) < 0.35);

            // --- PASSO 2: CALCULAR MODELOS ---
            const linear = fitPolynomial(points, 1);
            const quadratic = fitPolynomial(points, 2); 
            const cubic = fitPolynomial(points, 3);
            const sine = fitSineRobust(points);
            const log = fitLogarithmic(points);
            const exp = fitExponential(points);

            const models = [
                { name: "Reta", ...linear, type: 'poly' },
                { name: "Quadrática", ...quadratic, type: 'poly' },
                { name: "Cúbica", ...cubic, type: 'poly' },
                { name: sine.isCosine ? "Coseno" : "Seno", ...sine, type: 'sine' },
                { name: "Logarítmica", ...log, type: 'log' },
                { name: "Exponencial", ...exp, type: 'exp' }
            ];

            const validModels = models.filter(m => !isNaN(m.r2));
            if (validModels.length === 0) return null;

            // --- PASSO 3: SCORE ---
            validModels.forEach(m => {
                m.score = m.r2;
                
                if (m.name === "Reta") m.score -= 0.0;
                else if (m.type === 'exp' || m.type === 'log') m.score -= 0.01;
                else if (m.name === "Quadrática") m.score -= 0.03;
                else if (m.name === "Cúbica") m.score -= 0.08; 

                if (isLoopShape) {
                    if (m.name === "Reta") m.score -= 1.0;
                    if (m.type === 'exp') m.score -= 1.0;
                    if (m.type === 'log') m.score -= 1.0;

                    if (m.type === 'sine') {
                        if (directionChanges <= 1) {
                            m.score -= 0.40; 
                        }
                    }

                    if (m.name === "Cúbica" && directionChanges <= 1) {
                        m.score -= 0.10;
                    }

                } else {
                    if (m.name === "Quadrática") m.score -= 0.30;
                    if (m.name === "Cúbica") m.score -= 0.40;
                    if (m.type === 'sine') m.score -= 0.50;

                    if (m.name === "Exponencial" && isConcave) m.score -= 0.05; 
                    if (m.name === "Logarítmica" && isConvex) m.score -= 0.05;
                }
            });

            validModels.sort((a, b) => b.score - a.score);
            let best = validModels[0];
            const bestR2 = best.r2;
            const threshold = 0.05; 

            const linModel = validModels.find(m => m.name === "Reta");
            if (linModel && (bestR2 - linModel.r2) < threshold && linModel.r2 > 0.6) {
                best = linModel;
            }
            
            return best;
        }

        // --- VISUALIZATION OF RESULTS ---

        function drawAnalyzedCurves() {
            ctx.lineWidth = 4;
            
            analyzedModels.forEach((model, idx) => {
                const hue = (idx * 137) % 360; 
                
                // Limites do Canvas em coordenadas matemáticas
                const minCanvasX = -originX / scale;
                const maxCanvasX = (width - originX) / scale;

                const drawSegment = (xStart, xEnd, dashed, lightness) => {
                    if (xStart >= xEnd) return;

                    ctx.beginPath();
                    ctx.strokeStyle = `hsl(${hue}, 70%, ${lightness}%)`;
                    
                    if (dashed) {
                        ctx.setLineDash([10, 10]); // Traço interrompido
                    } else {
                        ctx.setLineDash([]); // Sólido
                    }

                    const step = Math.max((xEnd - xStart) / 100, 0.05); 
                    
                    let first = true;
                    for (let x = xStart; x <= xEnd + step/2; x += step) {
                        const curX = Math.min(x, xEnd); // Clamp
                        
                        let y = 0;
                        if (model.type === 'poly') {
                            y = model.coeffs.reduce((acc, c, i) => acc + c * Math.pow(curX, i), 0);
                        } else if (model.type === 'sine') {
                            y = model.a * Math.sin(model.b * curX + model.c) + model.d;
                        } else if (model.type === 'log') {
                            let val = model.useNegX ? -curX : curX;
                            if (val <= 0) { first = true; continue; } 
                            y = model.a + model.b * Math.log(val);
                        } else if (model.type === 'exp') {
                            y = model.a * Math.exp(model.b * curX);
                        }

                        let pt = mathToCanvas(curX, y);
                        
                        if (first) { ctx.moveTo(pt.x, pt.y); first = false; } else ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.stroke();
                };

                // 1. Extensão Esquerda
                drawSegment(minCanvasX, model.domain.min, true, 30);
                // 2. Parte Principal
                drawSegment(model.domain.min, model.domain.max, false, 60);
                // 3. Extensão Direita
                drawSegment(model.domain.max, maxCanvasX, true, 30);

                ctx.setLineDash([]);

                let startX = model.domain.min;
                let startY = 0; 
                if (model.type === 'poly') startY = model.coeffs.reduce((acc, c, i) => acc + c * Math.pow(startX, i), 0);
                else if (model.type === 'sine') startY = model.a * Math.sin(model.b * startX + model.c) + model.d;
                else if (model.type === 'log') { let v = model.useNegX ? -startX : startX; startY = (v > 0) ? model.a + model.b * Math.log(v) : 0; }
                else if (model.type === 'exp') startY = model.a * Math.exp(model.b * startX);

                let labelPt = mathToCanvas(startX, startY);
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(labelPt.x, labelPt.y, 4, 0, Math.PI*2);
                ctx.fill();
            });
        }

        function addResultToUI(model) {
            let latex = "";
            if (model.type === 'poly') {
                let isFirst = true;
                for (let i = model.coeffs.length - 1; i >= 0; i--) {
                    let c = model.coeffs[i];
                    if (Math.abs(c) < 0.01 && i !== 0) continue;
                    latex += (c >= 0 ? (isFirst ? "" : "+ ") : "- ") + Math.abs(c).toFixed(2) + (i === 1 ? "x " : (i > 1 ? `x^${i} ` : ""));
                    isFirst = false;
                }
                if (latex === "") latex = "0";
            } else if (model.type === 'sine') {
                let func = model.isCosine ? "\\cos" : "\\sin";
                let phase = model.isCosine ? model.displayC : model.c;
                latex = `${model.a.toFixed(2)} ${func}(${model.b.toFixed(2)}x ${phase >= 0 ? "+" : ""}${phase.toFixed(2)}) ${model.d >= 0 ? "+" : ""}${model.d.toFixed(2)}`;
            } else if (model.type === 'log') {
                let signB = model.b >= 0 ? "+" : "";
                let arg = model.useNegX ? "(-x)" : "x";
                latex = `${model.a.toFixed(2)} ${signB} ${model.b.toFixed(2)} \\ln(${arg})`;
            } else if (model.type === 'exp') {
                latex = `${model.a.toFixed(2)} e^{${model.b.toFixed(2)}x}`;
            }

            const item = document.createElement('div');
            item.className = "bg-slate-900/50 p-3 rounded border border-slate-700 relative group";
            
            const hue = ((model.id - 1) * 137) % 360;
            const colorDot = `<div class="w-3 h-3 rounded-full absolute top-3 right-3" style="background-color: hsl(${hue}, 70%, 60%);"></div>`;
            
            item.innerHTML = `
                ${colorDot}
                <div class="text-xs text-slate-400 font-mono mb-1">
                    f<sub>${model.id}</sub>(x) • ${model.name} <span class="opacity-50">(R² ${model.r2.toFixed(2)})</span>
                </div>
                <div class="overflow-x-auto whitespace-nowrap text-emerald-400 text-lg">
                    $$ f_{${model.id}}(x) = ${latex} $$
                </div>
                <div class="text-[10px] text-slate-500 mt-1 font-mono">
                    Domínio: [${model.domain.min.toFixed(1)} , ${model.domain.max.toFixed(1)}]
                </div>
            `;
            
            equationsList.appendChild(item);
        }

        // --- MATH HELPERS ---

        function fitLogarithmic(data) {
            let allPos = data.every(p => p.x > 0.01);
            let allNeg = data.every(p => p.x < -0.01);
            if (!allPos && !allNeg) return { r2: -Infinity }; 
            let useNegX = allNeg;
            let transformedData = data.map(p => ({ x: Math.log(useNegX ? -p.x : p.x), y: p.y }));
            let res = fitPolynomial(transformedData, 1); 
            let a = res.coeffs[0]; let b = res.coeffs[1];
            let r2 = calculateR2(data, (x) => {
                let val = useNegX ? -x : x;
                if (val <= 0) return 0;
                return a + b * Math.log(val);
            });
            return { a, b, useNegX, r2 };
        }

        function fitExponential(data) {
            let allPos = data.every(p => p.y > 0.01);
            let allNeg = data.every(p => p.y < -0.01);
            if (!allPos && !allNeg) return { r2: -Infinity }; 
            let isNegativeY = allNeg;
            let transformedData = data.map(p => ({ x: p.x, y: Math.log(isNegativeY ? -p.y : p.y) }));
            let res = fitPolynomial(transformedData, 1); 
            let A_lin = res.coeffs[0]; let B_lin = res.coeffs[1];
            let a = Math.exp(A_lin); if (isNegativeY) a = -a;
            let b = B_lin;
            let r2 = calculateR2(data, (x) => a * Math.exp(b * x));
            return { a, b, r2 };
        }

        function fitPolynomial(data, degree) {
            let N = data.length;
            let X = new Array(2 * degree + 1).fill(0);
            let Y = new Array(degree + 1).fill(0);
            for (let i = 0; i < N; i++) {
                let x = data[i].x; let y = data[i].y;
                for (let j = 0; j <= 2 * degree; j++) X[j] += Math.pow(x, j);
                for (let j = 0; j <= degree; j++) Y[j] += Math.pow(x, j) * y;
            }
            let A = [];
            for (let i = 0; i <= degree; i++) {
                A[i] = [];
                for (let j = 0; j <= degree; j++) A[i][j] = X[i + j];
            }
            let coeffs = gaussianElimination(A, Y);
            let r2 = calculateR2(data, (x) => {
                let yPred = 0;
                coeffs.forEach((c, i) => yPred += c * Math.pow(x, i));
                return yPred;
            });
            return { coeffs, degree, r2 };
        }

        function gaussianElimination(A, B) {
            let n = B.length;
            for (let i = 0; i < n; i++) {
                let maxEl = Math.abs(A[i][i]); let maxRow = i;
                for (let k = i + 1; k < n; k++) { if (Math.abs(A[k][i]) > maxEl) { maxEl = Math.abs(A[k][i]); maxRow = k; } }
                for (let k = i; k < n; k++) { let tmp = A[maxRow][k]; A[maxRow][k] = A[i][k]; A[i][k] = tmp; }
                let tmp = B[maxRow]; B[maxRow] = B[i]; B[i] = tmp;
                for (let k = i + 1; k < n; k++) {
                    let c = -A[k][i] / A[i][i];
                    for (let j = i; j < n; j++) { if (i === j) A[k][j] = 0; else A[k][j] += c * A[i][j]; }
                    B[k] += c * B[i];
                }
            }
            let x = new Array(n).fill(0);
            for (let i = n - 1; i > -1; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) sum += A[i][j] * x[j];
                x[i] = (B[i] - sum) / A[i][i];
            }
            return x;
        }

        function fitSineRobust(data) {
            let n = data.length;
            let bestR2 = -Infinity;
            let bestParams = null;
            let frequencies = [];
            for(let b = 0.1; b <= 4.0; b += 0.1) frequencies.push(b);
            frequencies.push(Math.PI/2, Math.PI, 2*Math.PI); 

            for (let b of frequencies) {
                let sumSin2 = 0, sumCos2 = 0, sumSinCos = 0, sumSin = 0, sumCos = 0, sumY = 0, sumYSin = 0, sumYCos = 0;
                for(let i=0; i<n; i++) {
                    let x = data[i].x; let y = data[i].y;
                    let s = Math.sin(b * x); let c = Math.cos(b * x);
                    sumSin2 += s*s; sumCos2 += c*c; sumSinCos += s*c;
                    sumSin += s; sumCos += c; sumY += y; sumYSin += y*s; sumYCos += y*c;
                }
                let A_mat = [[sumSin2, sumSinCos, sumSin], [sumSinCos, sumCos2, sumCos], [sumSin, sumCos, n]];
                let B_vec = [sumYSin, sumYCos, sumY];
                let coeffs = gaussianElimination(A_mat, B_vec);
                if(coeffs.some(val => isNaN(val))) continue;
                let r2 = calculateR2(data, (x) => coeffs[0] * Math.sin(b*x) + coeffs[1] * Math.cos(b*x) + coeffs[2]);
                if (r2 > bestR2) { bestR2 = r2; bestParams = { b, C1: coeffs[0], C2: coeffs[1], D: coeffs[2] }; }
            }
            if (!bestParams) return { r2: 0, a:0, b:0, c:0, d:0 };
            let b = bestParams.b;
            let a = Math.sqrt(bestParams.C1**2 + bestParams.C2**2);
            let c = Math.atan2(bestParams.C2, bestParams.C1);
            let isCosine = false;
            let displayC = c;
            let c_as_cos = c - Math.PI/2;
            while(c_as_cos > Math.PI) c_as_cos -= 2*Math.PI;
            while(c_as_cos < -Math.PI) c_as_cos += 2*Math.PI;
            if (Math.abs(c_as_cos) < Math.abs(c)) { isCosine = true; displayC = c_as_cos; }
            return { a, b, c, d: bestParams.D, r2: bestR2, isCosine, displayC };
        }

        function calculateR2(data, predictFn) {
            let n = data.length;
            let sumY = 0; data.forEach(p => sumY += p.y);
            let meanY = sumY / n;
            let ssTot = 0, ssRes = 0;
            data.forEach(p => {
                let yActual = p.y; let yPred = predictFn(p.x);
                ssTot += Math.pow(yActual - meanY, 2); ssRes += Math.pow(yActual - yPred, 2);
            });
            return ssTot === 0 ? 0 : 1 - (ssRes / ssTot);
        }

        resize();
    </script>
</body>
</html>